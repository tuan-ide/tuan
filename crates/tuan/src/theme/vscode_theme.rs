use hex_color::HexColor;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::{cmp::Ordering, path::PathBuf};
use xilem::Color;

use super::{Style, theme::Theme};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct VscodeTheme {
    name: String,
    #[serde(rename = "type")]
    color_scheme: ColorScheme,
    colors: HashMap<String, String>,
    token_colors: Vec<TokenColor>,
}

impl VscodeTheme {
    pub fn from_json(json: &str) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(serde_json::from_str(json)?)
    }

    pub fn from_path(path: PathBuf) -> Result<Self, Box<dyn std::error::Error>> {
        let content = std::fs::read_to_string(path)?;
        Self::from_json(&content)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
enum ColorScheme {
    Dark,
    Light,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct TokenColor {
    #[serde(deserialize_with = "deserialize_scopes")]
    scope: Vec<String>,
    settings: Settings,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct Settings {
    foreground: Option<String>,
    background: Option<String>,
    font_style: Option<String>,
}

// Below code is generated by ChatGPT because it knows better than me
// how to handle style selection for VSCode themes.

fn deserialize_scopes<'de, D>(deserializer: D) -> Result<Vec<String>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    use serde::de::{Error, Unexpected};
    use serde_json::Value;

    let v = Value::deserialize(deserializer)?;
    match v {
        Value::String(s) => Ok(s.split(',').map(|x| x.trim().to_string()).collect()),
        Value::Array(arr) => {
            let mut out = Vec::with_capacity(arr.len());
            for item in arr {
                if let Value::String(s) = item {
                    out.push(s);
                } else {
                    return Err(D::Error::invalid_type(
                        Unexpected::Other("non-string in array"),
                        &"string",
                    ));
                }
            }
            Ok(out)
        }
        _ => Err(D::Error::invalid_type(
            Unexpected::Other("non string/array"),
            &"string or array",
        )),
    }
}

#[derive(Debug)]
struct Selector {
    include: Sequence,
    excludes: Vec<Sequence>,
}

#[derive(Debug)]
struct Sequence(Vec<SimpleSelector>);

#[derive(Debug)]
struct SimpleSelector {
    segments: Vec<String>,
    is_wildcard: bool,
}

impl SimpleSelector {
    fn parse(s: &str) -> Self {
        let t = s.trim();
        if t == "*" {
            return Self {
                segments: vec![],
                is_wildcard: true,
            };
        }
        Self {
            segments: t.split('.').map(|x| x.to_string()).collect(),
            is_wildcard: false,
        }
    }
    fn matches(&self, scope: &str) -> bool {
        if self.is_wildcard {
            return true;
        }
        let target: Vec<&str> = scope.split('.').collect();
        if self.segments.len() > target.len() {
            return false;
        }
        for (i, seg) in self.segments.iter().enumerate() {
            if target[i] != seg {
                return false;
            }
        }
        true
    }
    fn specificity(&self) -> u32 {
        if self.is_wildcard {
            0
        } else {
            self.segments.len() as u32
        }
    }
}

impl Sequence {
    fn parse(s: &str) -> Self {
        let parts = s
            .split_whitespace()
            .filter(|p| !p.is_empty())
            .map(SimpleSelector::parse)
            .collect();
        Self(parts)
    }
    fn matches(&self, stack: &[&str]) -> Option<u32> {
        if self.0.is_empty() {
            return Some(0);
        }
        if !self.0.last().unwrap().matches(stack.last().unwrap()) {
            return None;
        }
        let mut spec = 0u32;
        let mut idx = 0usize;
        for (k, simple) in self.0.iter().enumerate() {
            let is_last = k + 1 == self.0.len();
            let end = if is_last {
                stack.len()
            } else {
                stack.len() - 1
            };
            let mut found = false;
            while idx < end {
                if simple.matches(stack[idx]) {
                    spec += simple.specificity();
                    found = true;
                    idx += 1;
                    break;
                }
                idx += 1;
            }
            if !found {
                return None;
            }
        }
        Some(spec)
    }
}

impl Selector {
    fn parse(s: &str) -> Self {
        let mut parts = s.split(" - ").map(str::trim);
        let include = Sequence::parse(parts.next().unwrap_or_default());
        let excludes = parts.map(Sequence::parse).collect();
        Self { include, excludes }
    }
    fn matches(&self, stack: &[&str]) -> Option<u32> {
        let spec = self.include.matches(stack)?;
        for ex in &self.excludes {
            if ex.matches(stack).is_some() {
                return None;
            }
        }
        Some(spec)
    }
}

#[derive(Debug, Default, Clone)]
struct Resolved {
    foreground: Option<Color>,
    background: Option<Color>,
    font_mask: Option<u8>,
}

fn parse_font_style(s: &str) -> u8 {
    if s.trim().eq_ignore_ascii_case("none") {
        return 0;
    }
    let mut mask = 0u8;
    for part in s.split_whitespace() {
        match part {
            "italic" => mask |= 1,
            "bold" => mask |= 2,
            "underline" => mask |= 4,
            "strikethrough" => mask |= 8,
            _ => {}
        }
    }
    mask
}

fn apply_rule(mut base: Resolved, settings: &Settings) -> Resolved {
    if let Some(fs) = &settings.font_style {
        base.font_mask = Some(parse_font_style(fs));
    }

    let fg = settings
        .foreground
        .clone()
        .and_then(|c| HexColor::parse(&c).ok())
        .map(|c| Color::from_rgba8(c.r, c.g, c.b, c.a));
    if let Some(fg) = fg {
        base.foreground = Some(fg);
    }

    let bg = settings
        .background
        .clone()
        .and_then(|c| HexColor::parse(&c).ok())
        .map(|c| Color::from_rgba8(c.r, c.g, c.b, c.a));
    if let Some(bg) = bg {
        base.background = Some(bg);
    }
    base
}

fn to_style(foreground: Option<Color>, background: Option<Color>, font_mask: Option<u8>) -> Style {
    let m = font_mask.unwrap_or(0);
    Style {
        color: None,
        foreground,
        background,
        italic: (m & 1) != 0,
        bold: (m & 2) != 0,
        underline: (m & 4) != 0,
        strikethrough: (m & 8) != 0,
    }
}

impl Theme for VscodeTheme {
    fn get_style(&self, tokens: Vec<&str>) -> Option<Style> {
        if tokens.is_empty() {
            return None;
        }
        let mut matches: Vec<(u32, usize, &Settings)> = Vec::new();
        let mut order = 0usize;
        for rule in &self.token_colors {
            for raw_selector in &rule.scope {
                let sel = Selector::parse(raw_selector);
                if let Some(spec) = sel.matches(&tokens) {
                    matches.push((spec, order, &rule.settings));
                }
                order += 1;
            }
        }
        if matches.is_empty() {
            for token in tokens {
                if let Some(color) = self.colors.get(token) {
                    let color = HexColor::parse(color)
                        .ok()
                        .map(|c| Color::from_rgba8(c.r, c.g, c.b, c.a));
                    if let Some(color) = color {
                        return Some(Style {
                            color: Some(color),
                            foreground: None,
                            background: None,
                            italic: false,
                            bold: false,
                            underline: false,
                            strikethrough: false,
                        });
                    }
                }
            }

            let fg = self
                .colors
                .get("editor.foreground")
                .cloned()
                .and_then(|c| HexColor::parse(&c).ok())
                .map(|c| Color::from_rgba8(c.r, c.g, c.b, c.a));
            let bg = self
                .colors
                .get("editor.background")
                .cloned()
                .and_then(|c| HexColor::parse(&c).ok())
                .map(|c| Color::from_rgba8(c.r, c.g, c.b, c.a));

            return fg.clone().or(bg.clone()).map(|_| to_style(fg, bg, None));
        }
        matches.sort_by(|a, b| match a.0.cmp(&b.0) {
            Ordering::Equal => a.1.cmp(&b.1),
            other => other,
        });
        let mut resolved = Resolved::default();
        for (_spec, _order, settings) in matches {
            resolved = apply_rule(resolved, settings);
        }
        if resolved.foreground.is_none() {
            let fg = self
                .colors
                .get("editor.foreground")
                .and_then(|c| HexColor::parse(&c).ok())
                .map(|c| Color::from_rgba8(c.r, c.g, c.b, c.a));
            if let Some(fg) = fg {
                resolved.foreground = Some(fg);
            }
        }
        Some(to_style(
            resolved.foreground,
            resolved.background,
            resolved.font_mask,
        ))
    }
}
